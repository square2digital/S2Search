/*
Deployment script for S2_Search

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

-- =============================
DO $$ BEGIN RAISE NOTICE 'Drop Table Definitions Start...'; END $$;
-- =============================
DROP TABLE IF EXISTS customers CASCADE;
DROP TABLE IF EXISTS feed_credentials CASCADE;
DROP TABLE IF EXISTS feed_current_documents CASCADE;
DROP TABLE IF EXISTS feeds CASCADE;
DROP TABLE IF EXISTS search_configuration CASCADE;
DROP TABLE IF EXISTS search_index CASCADE;
DROP TABLE IF EXISTS search_instance_keys CASCADE;
DROP TABLE IF EXISTS search_instances CASCADE;
DROP TABLE IF EXISTS synonyms CASCADE;
DROP TABLE IF EXISTS themes CASCADE;
DROP TABLE IF EXISTS search_insights_data CASCADE;
DROP TABLE IF EXISTS search_index_request_log CASCADE;

-- =============================
DO $$ BEGIN RAISE NOTICE 'Drop Type Definitions Start...'; END $$;
-- =============================
DROP TYPE IF EXISTS search_insights_data_type CASCADE;

-- =============================
DO $$ BEGIN RAISE NOTICE 'Drop Function Definitions'; END $$;
-- =============================
-- Cleaned up list with correct signatures for array types
DROP FUNCTION IF EXISTS add_synonym(uuid, uuid, TEXT, TEXT);
DROP FUNCTION IF EXISTS get_customer_by_id(uuid);
DROP FUNCTION IF EXISTS get_latest_feed(uuid);
DROP FUNCTION IF EXISTS get_search_index(uuid, uuid);
DROP FUNCTION IF EXISTS get_search_index_by_friendly_name(uuid, TEXT);
DROP FUNCTION IF EXISTS get_search_index_query_credentials_by_customer_endpoint(TEXT);
DROP FUNCTION IF EXISTS get_search_insights_by_data_categories(uuid, TIMESTAMP, TIMESTAMP, TEXT);
DROP FUNCTION IF EXISTS get_search_insights_search_count_by_date_range(uuid, TIMESTAMP, TIMESTAMP);
DROP FUNCTION IF EXISTS get_synonym_by_id(uuid, uuid);
DROP FUNCTION IF EXISTS get_synonym_by_key_word(uuid, TEXT);
DROP FUNCTION IF EXISTS get_synonyms(uuid);
DROP FUNCTION IF EXISTS get_theme_by_customer_id(uuid);
DROP FUNCTION IF EXISTS get_theme_by_id(uuid);
DROP FUNCTION IF EXISTS get_theme_by_search_index_id(uuid);
DROP FUNCTION IF EXISTS supersede_latest_feed(uuid);
DROP FUNCTION IF EXISTS supersede_synonym(uuid, uuid);
DROP FUNCTION IF EXISTS update_synonym(uuid, uuid, TEXT, TEXT);
DROP FUNCTION IF EXISTS update_theme(uuid, TEXT, TEXT, TEXT, TEXT, TEXT);
DROP FUNCTION IF EXISTS get_current_feed_documents(uuid, INT, INT);
DROP FUNCTION IF EXISTS get_current_feed_documents_total(uuid);
DROP FUNCTION IF EXISTS get_feed_credentials_username(uuid);
DROP FUNCTION IF EXISTS get_feed_data_format(uuid, TEXT);
DROP FUNCTION IF EXISTS get_latest_generic_synonyms_by_category(TEXT);
DROP FUNCTION IF EXISTS get_search_index_credentials(uuid, TEXT);
DROP FUNCTION IF EXISTS get_search_index_feed_processing_data(uuid, TEXT);
DROP FUNCTION IF EXISTS merge_feed_documents(uuid, TEXT[]); -- FIXED TYPE
DROP FUNCTION IF EXISTS add_data_points(uuid, search_insights_data_type[]); -- FIXED TYPE
DROP FUNCTION IF EXISTS add_search_request(uuid, DATE);
DROP FUNCTION IF EXISTS add_feed_credentials(uuid, TEXT, TEXT);
DROP FUNCTION IF EXISTS delete_feed_credentials(uuid, TEXT);
DROP FUNCTION IF EXISTS get_feed_credentials(uuid, TEXT);
DROP FUNCTION IF EXISTS update_feed_credentials(uuid, TEXT, TEXT);
DROP FUNCTION IF EXISTS add_feed(uuid, TEXT, TEXT);
DROP FUNCTION IF EXISTS get_theme_by_customer_endpoint(TEXT);
DROP FUNCTION IF EXISTS add_search_index(UUID, UUID, TEXT, TEXT, UUID);

-- =============================
DO $$ BEGIN RAISE NOTICE 'Extension Definitions'; END $$;
-- =============================
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =============================
DO $$ BEGIN RAISE NOTICE 'Type Definitions'; END $$;
-- =============================
CREATE TYPE search_insights_data_type AS (
    data_category TEXT,
    data_point TEXT,
    date DATE
);

-- =============================
DO $$ BEGIN RAISE NOTICE 'Table Definitions'; END $$;
-- =============================
CREATE TABLE customers (
    id                  UUID           NOT NULL,
    business_name       TEXT           NULL,
    customer_endpoint   TEXT           NULL,
    created_date        TIMESTAMP      NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date       TIMESTAMP      NULL,
    CONSTRAINT PK_customers PRIMARY KEY (id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE 'feed_credentials'; END $$;
-- =============================
CREATE TABLE feed_credentials (
    id                 UUID          NOT NULL DEFAULT gen_random_uuid(),
    search_index_id    UUID          NOT NULL,
    username           TEXT          NOT NULL,
    password_hash      TEXT          NOT NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date      TIMESTAMP     NULL,
    CONSTRAINT PK_feed_credentials PRIMARY KEY (id)
);
CREATE UNIQUE INDEX UIX_feed_credentials ON feed_credentials (search_index_id, username);

-- =============================
DO $$ BEGIN RAISE NOTICE 'feed_current_documents'; END $$;
-- =============================
CREATE TABLE feed_current_documents (
    id                 TEXT          NOT NULL,
    search_index_id    UUID          NOT NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT PK_feed_current_documents PRIMARY KEY (id, search_index_id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE 'feeds'; END $$;
-- =============================
CREATE TABLE feeds (
    id                 UUID          NOT NULL DEFAULT gen_random_uuid(),
    search_index_id    UUID          NOT NULL,
    is_latest          BOOLEAN       NOT NULL,
    feed_type          TEXT          NULL,
    data_format        TEXT          NULL,
    feed_schedule      TEXT          NULL,
    feed_cron          TEXT          NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date      TIMESTAMP     NULL,
    CONSTRAINT PK_feeds PRIMARY KEY (id)
);
CREATE UNIQUE INDEX UIX_feeds_latest ON feeds (search_index_id) WHERE is_latest;

-- =============================
DO $$ BEGIN RAISE NOTICE 'search_configuration'; END $$;
-- =============================
CREATE TABLE search_configuration (
    id                 UUID          NOT NULL DEFAULT gen_random_uuid(),
    search_index_id    UUID          NOT NULL,
    config_json        TEXT          NOT NULL,
    is_latest          BOOLEAN       NOT NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date      TIMESTAMP     NULL,
    CONSTRAINT PK_search_configuration PRIMARY KEY (id)
);
CREATE UNIQUE INDEX UIX_search_configuration_latest ON search_configuration (search_index_id) WHERE is_latest;

-- =============================
DO $$ BEGIN RAISE NOTICE 'search_index'; END $$;
-- =============================
CREATE TABLE search_index (
    id                 UUID          NOT NULL DEFAULT gen_random_uuid(),
    customer_id        UUID          NOT NULL,
    search_instance_id UUID          NOT NULL,
    index_name         TEXT          NOT NULL,
    data_format        TEXT          NULL,
    created_by_user_id UUID          NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date      TIMESTAMP     NULL,
    CONSTRAINT PK_search_index PRIMARY KEY (id)
);
CREATE UNIQUE INDEX UIX_search_index_name ON search_index (customer_id, index_name);

-- =============================
DO $$ BEGIN RAISE NOTICE 'search_instance_keys'; END $$;
-- =============================
CREATE TABLE search_instance_keys (
    id                 UUID          NOT NULL DEFAULT gen_random_uuid(),
    search_instance_id UUID          NOT NULL,
    name               TEXT          NOT NULL,
    api_key            TEXT          NOT NULL,
    key_type           TEXT          NOT NULL,
    is_latest          BOOLEAN       NOT NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date      TIMESTAMP     NULL,
    CONSTRAINT PK_search_instance_keys PRIMARY KEY (id)
);
CREATE UNIQUE INDEX UIX_search_instance_keys_latest ON search_instance_keys (search_instance_id, name) WHERE is_latest;

-- =============================
DO $$ BEGIN RAISE NOTICE 'search_instances'; END $$;
-- =============================
CREATE TABLE search_instances (
    id                 UUID          NOT NULL DEFAULT gen_random_uuid(),
    service_name       TEXT          NOT NULL,
    root_endpoint      TEXT          NOT NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date      TIMESTAMP     NULL,
    CONSTRAINT PK_search_instances PRIMARY KEY (id)
);
CREATE UNIQUE INDEX UIX_search_instances_endpoint ON search_instances (root_endpoint);

-- =============================
DO $$ BEGIN RAISE NOTICE 'synonyms'; END $$;
-- =============================
CREATE TABLE synonyms (
    id                 UUID          NOT NULL DEFAULT gen_random_uuid(),
    search_index_id    UUID          NULL,
    category           TEXT          NOT NULL,
    key_word           TEXT          NULL,
    solr_format        TEXT          NOT NULL,
    is_latest          BOOLEAN       NOT NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date      TIMESTAMP     NULL,
    CONSTRAINT PK_synonyms PRIMARY KEY (id)
);
CREATE UNIQUE INDEX UIX_synonyms_latest ON synonyms (search_index_id, category) WHERE is_latest;
CREATE UNIQUE INDEX UIX_synonyms_keyword ON synonyms (search_index_id, category, key_word) WHERE is_latest AND key_word IS NOT NULL;

-- =============================
DO $$ BEGIN RAISE NOTICE 'themes'; END $$;
-- =============================
CREATE TABLE themes (
    id                 UUID          NOT NULL DEFAULT gen_random_uuid(),
    customer_id        UUID          NULL,
    search_index_id    UUID          NULL,
    css_json           TEXT          NOT NULL,
    is_latest          BOOLEAN       NOT NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date      TIMESTAMP     NULL,
    CONSTRAINT PK_themes PRIMARY KEY (id)
);
CREATE UNIQUE INDEX UIX_themes_customer_latest ON themes (customer_id) WHERE is_latest AND customer_id IS NOT NULL;
CREATE UNIQUE INDEX UIX_themes_index_latest ON themes (search_index_id) WHERE is_latest AND search_index_id IS NOT NULL;

-- =============================
DO $$ BEGIN RAISE NOTICE 'search_insights_data'; END $$;
-- =============================
CREATE TABLE search_insights_data (
    id                 UUID          NOT NULL DEFAULT gen_random_uuid(),
    search_index_id    UUID          NOT NULL,
    data_category      TEXT          NOT NULL,
    data_point         TEXT          NOT NULL,
    count              INT           NOT NULL,
    date               DATE          NOT NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date      TIMESTAMP     NULL,
    CONSTRAINT PK_search_insights_data PRIMARY KEY (id)
);
-- REQUIRED for ON CONFLICT in add_data_points
CREATE UNIQUE INDEX UIX_search_insights_data_upsert
ON search_insights_data (search_index_id, data_category, data_point, date);

-- =============================
DO $$ BEGIN RAISE NOTICE 'search_index_request_log'; END $$;
-- =============================
CREATE TABLE search_index_request_log (
    id                 UUID          NOT NULL DEFAULT gen_random_uuid(),
    search_index_id    UUID          NOT NULL,
    count              INT           NOT NULL,
    date               DATE          NOT NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date      TIMESTAMP     NULL,
    CONSTRAINT PK_search_index_request_log PRIMARY KEY (id)
);
-- REQUIRED for ON CONFLICT in add_search_request
CREATE UNIQUE INDEX UIX_search_index_request_log_upsert
ON search_index_request_log (search_index_id, date);

-- =============================
DO $$ BEGIN RAISE NOTICE 'Foreign Key Definitions'; END $$;
-- =============================
ALTER TABLE feed_credentials ADD CONSTRAINT FK_feed_credentials_search_index FOREIGN KEY (search_index_id) REFERENCES search_index (id);
ALTER TABLE feed_current_documents ADD CONSTRAINT FK_feed_current_documents_search_index FOREIGN KEY (search_index_id) REFERENCES search_index (id);
ALTER TABLE feeds ADD CONSTRAINT FK_feeds_search_index FOREIGN KEY (search_index_id) REFERENCES search_index (id);
ALTER TABLE search_configuration ADD CONSTRAINT FK_search_configuration_search_index FOREIGN KEY (search_index_id) REFERENCES search_index (id);
ALTER TABLE search_index ADD CONSTRAINT FK_search_index_customers FOREIGN KEY (customer_id) REFERENCES customers (id);
ALTER TABLE search_index ADD CONSTRAINT FK_search_index_search_instances FOREIGN KEY (search_instance_id) REFERENCES search_instances (id);
ALTER TABLE search_instance_keys ADD CONSTRAINT FK_search_instance_keys_search_instances FOREIGN KEY (search_instance_id) REFERENCES search_instances (id);
ALTER TABLE synonyms ADD CONSTRAINT FK_synonyms_search_index FOREIGN KEY (search_index_id) REFERENCES search_index (id);
ALTER TABLE themes ADD CONSTRAINT FK_themes_customers FOREIGN KEY (customer_id) REFERENCES customers (id);
ALTER TABLE themes ADD CONSTRAINT FK_themes_search_index FOREIGN KEY (search_index_id) REFERENCES search_index (id);
ALTER TABLE search_insights_data ADD CONSTRAINT FK_search_insights_data_search_index FOREIGN KEY (search_index_id) REFERENCES search_index (id);
ALTER TABLE search_index_request_log ADD CONSTRAINT FK_search_index_request_log_search_index FOREIGN KEY (search_index_id) REFERENCES search_index (id);

-- =============================
DO $$ BEGIN RAISE NOTICE 'Function Definitions'; END $$;
-- =============================

-- =============================
DO $$ BEGIN RAISE NOTICE '1. add_search_index'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION add_search_index(
    p_customer_id UUID,
    p_search_instance_id UUID,
    p_index_name TEXT,
    p_data_format TEXT,
    p_created_by_user_id UUID
)
RETURNS UUID AS $$
DECLARE
    new_id UUID;
BEGIN
    INSERT INTO search_index (
        customer_id,
        search_instance_id,
        index_name,
        data_format,
        created_by_user_id
    )
    VALUES (
        p_customer_id,
        p_search_instance_id,
        p_index_name,
        p_data_format,
        p_created_by_user_id
    )
    RETURNING id INTO new_id;

    RETURN new_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '2. add_synonym'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION add_synonym(
    p_search_index_id UUID,
    p_category TEXT,
    p_key_word TEXT,
    p_solr_format TEXT
)
RETURNS UUID AS $$
DECLARE
    new_id UUID;
BEGIN
    -- Supersede existing synonyms in this category/keyword group
    PERFORM supersede_synonym(p_search_index_id, p_category, p_key_word);

    INSERT INTO synonyms (
        search_index_id,
        category,
        key_word,
        solr_format,
        is_latest
    )
    VALUES (
        p_search_index_id,
        p_category,
        p_key_word,
        p_solr_format,
        TRUE
    )
    RETURNING id INTO new_id;

    RETURN new_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '3. get_customer_by_id'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_customer_by_id(
    p_id UUID
)
RETURNS TABLE (
    id UUID,
    business_name TEXT,
    customer_endpoint TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.id,
        c.business_name,
        c.customer_endpoint,
        c.created_date,
        c.modified_date
    FROM customers c
    WHERE c.id = p_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '4. get_latest_feed'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_latest_feed(
    p_search_index_id UUID
)
RETURNS TABLE (
    id UUID,
    search_index_id UUID,
    is_latest BOOLEAN,
    feed_type TEXT,
    data_format TEXT,
    feed_schedule TEXT,
    feed_cron TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        f.id,
        f.search_index_id,
        f.is_latest,
        f.feed_type,
        f.data_format,
        f.feed_schedule,
        f.feed_cron,
        f.created_date,
        f.modified_date
    FROM feeds f
    WHERE f.search_index_id = p_search_index_id
      AND f.is_latest = TRUE;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '5. get_search_index'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_index(
    p_customer_id UUID,
    p_search_index_id UUID
)
RETURNS TABLE (
    id UUID,
    customer_id UUID,
    search_instance_id UUID,
    index_name TEXT,
    data_format TEXT,
    created_by_user_id UUID,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        si.id,
        si.customer_id,
        si.search_instance_id,
        si.index_name,
        si.data_format,
        si.created_by_user_id,
        si.created_date,
        si.modified_date
    FROM search_index si
    WHERE si.customer_id = p_customer_id
      AND si.id = p_search_index_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '6. get_search_index_by_friendly_name'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_index_by_friendly_name(
    p_customer_id UUID,
    p_index_name TEXT
)
RETURNS TABLE (
    id UUID,
    customer_id UUID,
    search_instance_id UUID,
    index_name TEXT,
    data_format TEXT,
    created_by_user_id UUID,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        si.id,
        si.customer_id,
        si.search_instance_id,
        si.index_name,
        si.data_format,
        si.created_by_user_id,
        si.created_date,
        si.modified_date
    FROM search_index si
    WHERE si.customer_id = p_customer_id
      AND si.index_name = p_index_name;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '7. get_search_index_query_credentials_by_customer_endpoint'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_index_query_credentials_by_customer_endpoint(
    p_customer_endpoint TEXT
)
RETURNS TABLE (
    search_index_id UUID,
    search_instance_id UUID,
    search_instance_name TEXT,
    root_endpoint TEXT,
    api_key TEXT,
    data_format TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        si.id,
        i.id,
        i.service_name,
        i.root_endpoint,
        ik.api_key,
        si.data_format
    FROM customers c
    INNER JOIN search_index si ON si.customer_id = c.id
    INNER JOIN search_instances i ON i.id = si.search_instance_id
    INNER JOIN search_instance_keys ik ON ik.search_instance_id = i.id
        AND ik.key_type = 'Query'
        AND ik.name = 'Primary Query key'
        AND ik.is_latest = TRUE
    WHERE c.customer_endpoint = p_customer_endpoint;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '8. get_search_insights_by_data_categories'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_insights_by_data_categories(
    p_search_index_id UUID,
    p_start_date TIMESTAMP,
    p_end_date TIMESTAMP,
    p_data_category TEXT
)
RETURNS TABLE (
    data_category TEXT,
    data_point TEXT,
    sum_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        sid.data_category,
        sid.data_point,
        CAST(SUM(sid.count) AS BIGINT)
    FROM search_insights_data sid
    WHERE sid.search_index_id = p_search_index_id
      AND sid.date >= p_start_date::DATE
      AND sid.date <= p_end_date::DATE
      AND sid.data_category = p_data_category
    GROUP BY
        sid.data_category,
        sid.data_point
    ORDER BY
        sum_count DESC;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '9. get_search_insights_search_count_by_date_range'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_insights_search_count_by_date_range(
    p_search_index_id UUID,
    p_start_date TIMESTAMP,
    p_end_date TIMESTAMP
)
RETURNS TABLE (
    log_date DATE,
    sum_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        sirl.date,
        CAST(SUM(sirl.count) AS BIGINT)
    FROM search_index_request_log sirl
    WHERE sirl.search_index_id = p_search_index_id
      AND sirl.date >= p_start_date::DATE
      AND sirl.date <= p_end_date::DATE
    GROUP BY
        sirl.date
    ORDER BY
        sirl.date ASC;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '10. get_synonym_by_id'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_synonym_by_id(
    p_search_index_id UUID,
    p_id UUID
)
RETURNS TABLE (
    id UUID,
    search_index_id UUID,
    category TEXT,
    key_word TEXT,
    solr_format TEXT,
    is_latest BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        s.id,
        s.search_index_id,
        s.category,
        s.key_word,
        s.solr_format,
        s.is_latest,
        s.created_date,
        s.modified_date
    FROM synonyms s
    WHERE s.search_index_id = p_search_index_id
      AND s.id = p_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '11. get_synonym_by_key_word'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_synonym_by_key_word(
    p_search_index_id UUID,
    p_key_word TEXT
)
RETURNS TABLE (
    id UUID,
    search_index_id UUID,
    category TEXT,
    key_word TEXT,
    solr_format TEXT,
    is_latest BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        s.id,
        s.search_index_id,
        s.category,
        s.key_word,
        s.solr_format,
        s.is_latest,
        s.created_date,
        s.modified_date
    FROM synonyms s
    WHERE s.search_index_id = p_search_index_id
      AND s.key_word = p_key_word
      AND s.is_latest = TRUE;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '12. get_synonyms'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_synonyms(
    p_search_index_id UUID
)
RETURNS TABLE (
    id UUID,
    search_index_id UUID,
    category TEXT,
    key_word TEXT,
    solr_format TEXT,
    is_latest BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        s.id,
        s.search_index_id,
        s.category,
        s.key_word,
        s.solr_format,
        s.is_latest,
        s.created_date,
        s.modified_date
    FROM synonyms s
    WHERE s.search_index_id = p_search_index_id
      AND s.is_latest = TRUE;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '13. get_theme_by_customer_id'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_theme_by_customer_id(
    p_customer_id UUID
)
RETURNS TABLE (
    id UUID,
    customer_id UUID,
    search_index_id UUID,
    css_json TEXT,
    is_latest BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.id,
        t.customer_id,
        t.search_index_id,
        t.css_json,
        t.is_latest,
        t.created_date,
        t.modified_date
    FROM themes t
    WHERE t.customer_id = p_customer_id
      AND t.is_latest = TRUE;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '14. get_theme_by_id'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_theme_by_id(
    p_id UUID
)
RETURNS TABLE (
    id UUID,
    customer_id UUID,
    search_index_id UUID,
    css_json TEXT,
    is_latest BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.id,
        t.customer_id,
        t.search_index_id,
        t.css_json,
        t.is_latest,
        t.created_date,
        t.modified_date
    FROM themes t
    WHERE t.id = p_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '15. get_theme_by_search_index_id'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_theme_by_search_index_id(
    p_search_index_id UUID
)
RETURNS TABLE (
    id UUID,
    customer_id UUID,
    search_index_id UUID,
    css_json TEXT,
    is_latest BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.id,
        t.customer_id,
        t.search_index_id,
        t.css_json,
        t.is_latest,
        t.created_date,
        t.modified_date
    FROM themes t
    WHERE t.search_index_id = p_search_index_id
      AND t.is_latest = TRUE;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '16. supersede_latest_feed'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION supersede_latest_feed(
    p_search_index_id UUID
)
RETURNS VOID AS $$
BEGIN
    UPDATE feeds
    SET is_latest = FALSE,
        modified_date = CURRENT_TIMESTAMP
    WHERE search_index_id = p_search_index_id
      AND is_latest = TRUE;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '17. supersede_synonym'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION supersede_synonym(
    p_search_index_id UUID,
    p_category TEXT,
    p_key_word TEXT
)
RETURNS VOID AS $$
BEGIN
    UPDATE synonyms
    SET is_latest = FALSE,
        modified_date = CURRENT_TIMESTAMP
    WHERE search_index_id = p_search_index_id
      AND category = p_category
      AND key_word = p_key_word
      AND is_latest = TRUE;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '18. update_synonym'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION update_synonym(
    p_id UUID,
    p_search_index_id UUID,
    p_key_word TEXT,
    p_solr_format TEXT
)
RETURNS INT AS $$
DECLARE
    rows_updated INT := 0;
BEGIN
    UPDATE synonyms
    SET key_word = p_key_word,
        solr_format = p_solr_format,
        modified_date = CURRENT_TIMESTAMP
    WHERE id = p_id
      AND search_index_id = p_search_index_id
      AND is_latest = TRUE;

    GET DIAGNOSTICS rows_updated = ROW_COUNT;
    RETURN rows_updated;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '19. update_theme'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION update_theme(
    p_id UUID,
    p_customer_id UUID,
    p_search_index_id UUID,
    p_css_json TEXT,
    p_created_by_user_id UUID,
    p_is_latest BOOLEAN
)
RETURNS INT AS $$
DECLARE
    rows_updated INT := 0;
BEGIN
    -- If setting to latest, supersede existing latest themes for this customer/index
    IF p_is_latest = TRUE THEN
        IF p_customer_id IS NOT NULL THEN
            UPDATE themes
            SET is_latest = FALSE, modified_date = CURRENT_TIMESTAMP
            WHERE customer_id = p_customer_id AND is_latest = TRUE;
        ELSIF p_search_index_id IS NOT NULL THEN
            UPDATE themes
            SET is_latest = FALSE, modified_date = CURRENT_TIMESTAMP
            WHERE search_index_id = p_search_index_id AND is_latest = TRUE;
        END IF;
    END IF;

    UPDATE themes
    SET css_json = p_css_json,
        is_latest = p_is_latest,
        modified_date = CURRENT_TIMESTAMP
    WHERE id = p_id;

    GET DIAGNOSTICS rows_updated = ROW_COUNT;
    RETURN rows_updated;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '20. get_current_feed_documents'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_current_feed_documents(
    p_search_index_id UUID,
    p_offset INT,
    p_limit INT
)
RETURNS TABLE (
    id TEXT,
    search_index_id UUID,
    created_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        fcd.id,
        fcd.search_index_id,
        fcd.created_date
    FROM feed_current_documents fcd
    WHERE fcd.search_index_id = p_search_index_id
    ORDER BY fcd.created_date DESC
    OFFSET p_offset
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '21. get_current_feed_documents_total'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_current_feed_documents_total(
    p_search_index_id UUID
)
RETURNS BIGINT AS $$
DECLARE
    total_count BIGINT;
BEGIN
    SELECT COUNT(*) INTO total_count
    FROM feed_current_documents
    WHERE search_index_id = p_search_index_id;

    RETURN total_count;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '22. get_feed_credentials_username'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_feed_credentials_username(
    p_search_index_id UUID
)
RETURNS TEXT AS $$
DECLARE
    username_val TEXT;
BEGIN
    SELECT username INTO username_val
    FROM feed_credentials
    WHERE search_index_id = p_search_index_id
    LIMIT 1;

    RETURN username_val;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '23. get_feed_data_format'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_feed_data_format(
    p_customer_id UUID,
    p_search_index_name TEXT
)
RETURNS TEXT AS $$
DECLARE
    data_format TEXT;
BEGIN
    SELECT f.data_format
    INTO data_format
    FROM search_index si
    INNER JOIN feeds f ON f.search_index_id = si.id AND f.is_latest = TRUE
    WHERE si.customer_id = p_customer_id
      AND si.index_name = p_search_index_name
    LIMIT 1;

    RETURN data_format;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '24. get_latest_generic_synonyms_by_category'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_latest_generic_synonyms_by_category(
    p_category TEXT
)
RETURNS TABLE (
    id UUID,
    category TEXT,
    solr_format TEXT,
    created_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        s.id,
        s.category,
        s.solr_format,
        s.created_date
    FROM synonyms s
    WHERE s.category = p_category
      AND s.is_latest = TRUE
      AND s.search_index_id IS NULL; -- Ensures it is 'generic' (not linked to a specific index)
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '25. get_search_index_credentials'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_index_credentials(
    p_customer_id UUID,
    p_search_index_name TEXT
)
RETURNS TABLE (
    search_index_id UUID,
    search_index_name_lower TEXT,
    search_instance_id UUID,
    search_instance_name TEXT,
    root_endpoint TEXT,
    api_key TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        si.id,
        LOWER(si.index_name),
        i.id,
        i.service_name,
        i.root_endpoint,
        ik.api_key
    FROM search_index si
    INNER JOIN search_instances i ON i.id = si.search_instance_id -- CORRECTED JOIN
    INNER JOIN search_instance_keys ik ON ik.search_instance_id = i.id -- CORRECTED JOIN
        AND ik.key_type = 'Admin'
        AND ik.name = 'Primary Admin key'
        AND ik.is_latest = TRUE
    WHERE si.customer_id = p_customer_id
      AND si.index_name = p_search_index_name;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '26. get_search_index_feed_processing_data'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_index_feed_processing_data(
    p_customer_id UUID,
    p_search_index_name TEXT
)
RETURNS TABLE (
    search_index_id UUID,
    search_index_name_lower TEXT,
    search_instance_id UUID,
    search_instance_name TEXT,
    root_endpoint TEXT,
    api_key TEXT,
    feed_data_format TEXT,
    customer_endpoint TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        si.id,
        LOWER(si.index_name),
        i.id,
        i.service_name,
        i.root_endpoint,
        ik.api_key,
        f.data_format,
        c.customer_endpoint
    FROM search_index si
    INNER JOIN search_instances i ON i.id = si.search_instance_id -- CORRECTED JOIN
    INNER JOIN search_instance_keys ik ON ik.search_instance_id = i.id -- CORRECTED JOIN
        AND ik.key_type = 'Admin'
        AND ik.name = 'Primary Admin key'
        AND ik.is_latest = TRUE
    LEFT JOIN feeds f ON f.search_index_id = si.id
    LEFT JOIN customers c ON si.customer_id = c.id
    WHERE si.customer_id = p_customer_id
      AND si.index_name = p_search_index_name
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '27. merge_feed_documents'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION merge_feed_documents(
    p_search_index_id UUID,
    p_new_feed_documents TEXT[] -- CRITICAL FIX: Changed from UUID[] to TEXT[]
)
RETURNS VOID AS $$
DECLARE
    utc_now TIMESTAMP := NOW();
BEGIN
    -- Update existing documents
    UPDATE feed_current_documents AS target
    SET created_date = utc_now
    WHERE target.search_index_id = p_search_index_id
      AND target.id = ANY(p_new_feed_documents);

    -- Insert new documents
    INSERT INTO feed_current_documents (id, search_index_id, created_date)
    SELECT doc_id, p_search_index_id, utc_now
    FROM UNNEST(p_new_feed_documents) AS doc_id
    WHERE doc_id NOT IN (
        SELECT id
        FROM feed_current_documents
        WHERE search_index_id = p_search_index_id
    );

    -- Delete documents not in the new list
    DELETE FROM feed_current_documents
    WHERE search_index_id = p_search_index_id
      AND id NOT IN (SELECT * FROM UNNEST(p_new_feed_documents));
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '28. add_data_points'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION add_data_points(
    p_search_index_id UUID,
    p_search_insights_data search_insights_data_type[]
)
RETURNS VOID AS $$
DECLARE
    utc_now TIMESTAMP := NOW();
    record_item search_insights_data_type;
BEGIN
    -- Use a loop for the composite type array
    FOR record_item IN
        SELECT * FROM UNNEST(p_search_insights_data)
    LOOP
        INSERT INTO search_insights_data (
            search_index_id,
            data_category,
            data_point,
            count,
            date,
            modified_date
        )
        VALUES (
            p_search_index_id,
            record_item.data_category,
            record_item.data_point,
            1,
            record_item.date,
            utc_now
        )
        ON CONFLICT (search_index_id, data_category, data_point, date) -- Uses unique index
        DO UPDATE SET
            count = search_insights_data.count + 1,
            modified_date = utc_now;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '29. add_search_request'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION add_search_request(
    p_search_index_id UUID,
    p_date DATE
)
RETURNS VOID AS $$
DECLARE
    utc_now TIMESTAMP := NOW();
BEGIN
    INSERT INTO search_index_request_log (
        search_index_id,
        count,
        date,
        modified_date
    )
    VALUES (
        p_search_index_id,
        1,
        p_date,
        utc_now
    )
    ON CONFLICT (search_index_id, date) -- Uses unique index
    DO UPDATE SET
        count = search_index_request_log.count + 1,
        modified_date = utc_now;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '30. add_feed_credentials'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION add_feed_credentials(
    p_search_index_id UUID,
    p_username TEXT,
    p_password_hash TEXT
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO feed_credentials (
        search_index_id,
        username,
        password_hash,
        created_date
    )
    VALUES (
        p_search_index_id,
        p_username,
        p_password_hash,
        NOW()
    )
    ON CONFLICT (search_index_id, username) DO NOTHING; -- Assuming you want to prevent duplicates or use a separate update func
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '31. delete_feed_credentials'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION delete_feed_credentials(
    p_search_index_id UUID,
    p_username TEXT
)
RETURNS INT AS $$
DECLARE
    rows_deleted INT := 0;
BEGIN
    DELETE FROM feed_credentials
    WHERE search_index_id = p_search_index_id
      AND username = p_username;

    GET DIAGNOSTICS rows_deleted = ROW_COUNT;
    RETURN rows_deleted;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '32. get_feed_credentials'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_feed_credentials(
    p_search_index_id UUID,
    p_username TEXT
)
RETURNS TABLE (
    id UUID,
    search_index_id UUID,
    username TEXT,
    password_hash TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        fc.id,
        fc.search_index_id,
        fc.username,
        fc.password_hash,
        fc.created_date,
        fc.modified_date
    FROM feed_credentials fc
    WHERE fc.search_index_id = p_search_index_id
      AND fc.username = p_username;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '33. update_feed_credentials'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION update_feed_credentials(
    p_search_index_id UUID,
    p_username TEXT,
    p_password_hash TEXT
) RETURNS INT AS $$
DECLARE
    rows_updated INT := 0;
BEGIN
    UPDATE feed_credentials
    SET password_hash = p_password_hash,
        modified_date = CURRENT_TIMESTAMP
    WHERE search_index_id = p_search_index_id
      AND username = p_username;
    GET DIAGNOSTICS rows_updated = ROW_COUNT;
    RETURN rows_updated;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '34. add_feed'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION add_feed(
    p_search_index_id UUID,
    p_feed_type TEXT,
    p_feed_cron TEXT
) RETURNS INT AS $$
DECLARE
    rows_inserted INT := 0;
BEGIN
    -- Supersede previous latest feed
    PERFORM supersede_latest_feed(p_search_index_id);

    -- Insert new feed
    INSERT INTO feeds (
        search_index_id,
        feed_type,
        feed_schedule,
        feed_cron,
        is_latest
    )
    VALUES (
        p_search_index_id,
        p_feed_type,
        NULL, -- You might want to update this to pass a schedule if needed
        p_feed_cron,
        TRUE
    );

    GET DIAGNOSTICS rows_inserted = ROW_COUNT;
    RETURN rows_inserted;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '35. get_theme_by_customer_endpoint'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_theme_by_customer_endpoint(
    p_customer_endpoint TEXT
)
RETURNS TABLE (
    id UUID,
    customer_id UUID,
    search_index_id UUID,
    css_json TEXT,
    is_latest BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.id,
        t.customer_id,
        t.search_index_id,
        t.css_json,
        t.is_latest,
        t.created_date,
        t.modified_date
    FROM themes t
    INNER JOIN customers c ON t.customer_id = c.id
    WHERE c.customer_endpoint = p_customer_endpoint
      AND t.is_latest = TRUE
    LIMIT 1; -- Should only be one latest theme per customer
END;
$$ LANGUAGE plpgsql;
