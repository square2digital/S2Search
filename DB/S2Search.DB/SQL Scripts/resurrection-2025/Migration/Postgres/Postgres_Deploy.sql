/*
Deployment script for S2_Search

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

-- =============================
DO $$ BEGIN RAISE NOTICE 'Drop Table Definitions Start...'; END $$;
-- =============================
DROP TABLE IF EXISTS customers CASCADE;
DROP TABLE IF EXISTS feed_credentials CASCADE;
DROP TABLE IF EXISTS feed_current_documents CASCADE;
DROP TABLE IF EXISTS feeds CASCADE;
DROP TABLE IF EXISTS search_configuration CASCADE;
DROP TABLE IF EXISTS search_index CASCADE;
DROP TABLE IF EXISTS search_instance_keys CASCADE;
DROP TABLE IF EXISTS search_instances CASCADE;
DROP TABLE IF EXISTS synonyms CASCADE;
DROP TABLE IF EXISTS themes CASCADE;
DROP TABLE IF EXISTS search_insights_data CASCADE;
DROP TABLE IF EXISTS search_index_request_log CASCADE;

-- =============================
DO $$ BEGIN RAISE NOTICE '============================='; END $$;
DO $$ BEGIN RAISE NOTICE 'Create Tables'; END $$;
DO $$ BEGIN RAISE NOTICE '============================='; END $$;
-- =============================

-- =============================
DO $$ BEGIN RAISE NOTICE '1. customers'; END $$;
-- =============================
CREATE TABLE customers (
    id                  UUID           NOT NULL,
    business_name       TEXT           NULL,
    customer_endpoint   TEXT           NULL,
    created_date        TIMESTAMP      NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date       TIMESTAMP      NULL,
    CONSTRAINT PK_customers PRIMARY KEY (id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE '2. feed_credentials'; END $$;
-- =============================
CREATE TABLE feed_credentials (
    id                 UUID          NOT NULL,
    search_index_id    UUID          NOT NULL,
    username           TEXT          NOT NULL,
    password_hash      TEXT          NOT NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date      TIMESTAMP     NULL,
    CONSTRAINT PK_feed_credentials PRIMARY KEY (id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE '3. feed_current_documents'; END $$;
-- =============================
CREATE TABLE feed_current_documents (
    id                 TEXT           NOT NULL,
    search_index_id    UUID           NOT NULL,
    created_date       TIMESTAMP      NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT PK_feed_current_documents PRIMARY KEY (id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE '4. feeds'; END $$;
-- =============================
CREATE TABLE feeds (
    id                 UUID          NOT NULL,
    feed_type          TEXT          NOT NULL,
    feed_schedule_cron TEXT          NOT NULL,
    search_index_id    UUID          NOT NULL,
    data_format        TEXT          NOT NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    superseded_date    TIMESTAMP     NULL,
    is_latest          BOOLEAN       NOT NULL DEFAULT TRUE,
    CONSTRAINT PK_feeds PRIMARY KEY (id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE '5. search_configuration'; END $$;
-- =============================
CREATE TABLE search_configuration (
    id               UUID           NOT NULL,
    value            TEXT           NOT NULL,
    search_index_id  UUID           NOT NULL,
    key              TEXT           NOT NULL,
    friendly_name    TEXT           NOT NULL,
    description      TEXT           NOT NULL,
    data_type        TEXT           NOT NULL,
    order_index      INT            NULL,
    created_date     TIMESTAMP      NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date    TIMESTAMP      NULL,
    CONSTRAINT PK_search_configuration PRIMARY KEY (id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE '6. search_index'; END $$;
-- =============================
CREATE TABLE search_index (
    id                 UUID         NOT NULL,
    customer_id        UUID         NOT NULL,
    search_instance_id UUID         NULL,
    index_name         TEXT         NOT NULL,
    friendly_name      TEXT         NOT NULL,
    pricing_sku_id     TEXT         NOT NULL,
    created_date       TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT PK_search_index PRIMARY KEY (id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE '7. search_instance_keys'; END $$;
-- =============================
CREATE TABLE search_instance_keys (
    id                 UUID          NOT NULL,
    search_instance_id UUID          NOT NULL,
    key_type           TEXT          NOT NULL,
    name               TEXT          NOT NULL,
    api_key            TEXT          NOT NULL,
    created_date       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date      TIMESTAMP     NULL,
    is_latest          BOOLEAN       NOT NULL DEFAULT TRUE,
    CONSTRAINT PK_search_instance_keys PRIMARY KEY (id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE '8. search_instances'; END $$;
-- =============================
CREATE TABLE search_instances (
    id                UUID           NOT NULL,
    customer_id       UUID           NOT NULL,
    service_name      TEXT           NOT NULL,
    location          TEXT           NOT NULL,
    pricing_tier      TEXT           NOT NULL,
    replicas          INT            NULL,
    partitions        INT            NULL,
    is_shared         BOOLEAN        NOT NULL,
    type              TEXT           NOT NULL,
    root_endpoint     TEXT           NULL,
    CONSTRAINT PK_search_instances PRIMARY KEY (id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE '9. synonyms'; END $$;
-- =============================
CREATE TABLE synonyms (
    id                 UUID           NOT NULL,
    category           TEXT           NULL,
    search_index_id    UUID           NULL,
    key_word           TEXT           NULL,
    solr_format        TEXT           NOT NULL,
    created_date       TIMESTAMP      NOT NULL,
    superseded_date    TIMESTAMP      NULL,
    is_latest          BOOLEAN        NOT NULL,
    CONSTRAINT PK_synonyms PRIMARY KEY (id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE '10. themes'; END $$;
-- =============================
CREATE TABLE themes (
    id                   UUID         NOT NULL,
    primary_hex_colour   TEXT         NULL,
    secondary_hex_colour TEXT         NULL,
    nav_bar_hex_colour   TEXT         NULL,
    logo_url             TEXT         NULL,
    missing_image_url    TEXT         NULL,
    customer_id          UUID         NULL,
    search_index_id      UUID         NULL,
    created_date         TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date        TIMESTAMP    NULL,
    CONSTRAINT PK_themes PRIMARY KEY (id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE '11. search_insights_data'; END $$;
-- =============================
CREATE TABLE search_insights_data (
    id               UUID           NOT NULL DEFAULT gen_random_UUID(),
    search_index_id    UUID         NOT NULL,
    data_category     TEXT          NOT NULL,
    data_point        TEXT          NOT NULL,
    count            INT            NOT NULL DEFAULT 0,
    date             TIMESTAMP      NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_date      TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date     TIMESTAMP     NULL,
    CONSTRAINT PK_search_insights_data PRIMARY KEY (id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE '12. search_index_request_log'; END $$;
-- =============================
CREATE TABLE search_index_request_log (
    id               UUID         NOT NULL DEFAULT gen_random_UUID(),
    search_index_id  UUID         NOT NULL,
    count            INT          NOT NULL DEFAULT 0,
    date             TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_date     TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_date    TIMESTAMP    NULL,
    CONSTRAINT PK_search_index_request_log PRIMARY KEY (id)
);

-- =============================
DO $$ BEGIN RAISE NOTICE '============================='; END $$;
DO $$ BEGIN RAISE NOTICE 'Create Types'; END $$;
DO $$ BEGIN RAISE NOTICE '============================='; END $$;
-- =============================

-- =============================
DO $$ BEGIN RAISE NOTICE '1. search_insights_data_type'; END $$;
-- =============================
DROP TYPE IF EXISTS search_insights_data_type CASCADE;
CREATE TYPE search_insights_data_type AS (
  data_category TEXT,
  data_point    TEXT,
  date          DATE
);


-- =============================
DO $$ BEGIN RAISE NOTICE '============================='; END $$;
DO $$ BEGIN RAISE NOTICE 'Create Functions'; END $$;
DO $$ BEGIN RAISE NOTICE '============================='; END $$;
-- =============================

-- =============================
DO $$ BEGIN RAISE NOTICE '1. get_customer_by_id'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_customer_by_id(customer_id UUID)
RETURNS TABLE (id UUID, business_name text) AS $$
BEGIN
    RETURN QUERY
    SELECT c.id, c.business_name
    FROM customers c
    WHERE c.id = customer_id;
END;

$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '2. get_customer_full'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_customer_full(customer_id UUID)
RETURNS TABLE (
    id UUID,
    business_name text
) AS $$
BEGIN
    RETURN QUERY
    SELECT c.id, c.business_name
    FROM customers c
    WHERE c.id = customer_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '3. get_latest_feed'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_latest_feed(
    p_search_index_id UUID
)
RETURNS TABLE (
    id UUID,
    search_index_id UUID,
    feed_type text,
    feed_schedule_cron text,
    created_date timestamp,
    superseded_date timestamp,
    is_latest boolean
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        f.id,
        f.search_index_id,
        f.feed_type,
        f.feed_schedule_cron,
        f.created_date,
        f.superseded_date,
        f.is_latest
    FROM feeds f
    WHERE f.search_index_id = p_search_index_id
      AND f.is_latest = TRUE
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '4. get_search_index'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_index(
    p_search_index_id UUID,
    p_customer_id UUID
) RETURNS TABLE (
    id UUID,
    customer_id UUID,
    index_name text,
    friendly_name text,
    root_endpoint text,
    pricing_tier text,
    created_date timestamp,
    instance_id UUID,
    service_name text,
    location text,
    instance_pricing_tier text,
    replicas int,
    partitions int,
    is_shared boolean
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        search.id,
        search.customer_id,
        search.index_name,
        search.friendly_name,
        service.root_endpoint,
        service.pricing_tier,
        search.created_date,
        service.id,
        service.service_name,
        service.location,
        service.pricing_tier,
        service.replicas,
        service.partitions,
        service.is_shared
    FROM search_index search
    LEFT OUTER JOIN search_instances service ON service.id = search.search_instance_id
    WHERE search.id = p_search_index_id
      AND search.customer_id = p_customer_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '5. get_search_index_by_friendly_name'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_index_by_friendly_name(
    p_customer_id UUID,
    p_friendly_name TEXT
) RETURNS TABLE (
    id UUID,
    search_instance_id UUID,
    customer_id UUID,
    friendly_name text,
    index_name text
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        si.id,
        si.search_instance_id,
        si.customer_id,
        si.friendly_name,
        si.index_name
    FROM search_index si
    WHERE si.customer_id = p_customer_id
      AND si.friendly_name = p_friendly_name;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '6. get_search_index_full'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_index_full(
    p_search_index_id UUID,
    p_customer_id UUID
) RETURNS TABLE (
    id UUID,
    customer_id UUID,
    index_name text,
    friendly_name text,
    root_endpoint text,
    pricing_tier text,
    created_date timestamp,
    instance_id UUID,
    service_name text,
    location text,
    instance_pricing_tier text,
    replicas int,
    partitions int,
    is_shared boolean
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        search.id,
        search.customer_id,
        search.index_name,
        search.friendly_name,
        service.root_endpoint,
        service.pricing_tier,
        search.created_date,
        service.id,
        service.service_name,
        service.location,
        service.pricing_tier,
        service.replicas,
        service.partitions,
        service.is_shared
    FROM search_index search
    LEFT OUTER JOIN search_instances service ON service.id = search.search_instance_id
    WHERE search.id = p_search_index_id
      AND search.customer_id = p_customer_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '7. GetSynonymById'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_synonym_by_id(
    p_search_index_id UUID,
    p_synonym_id UUID
) RETURNS TABLE (
    id UUID,
    search_index_id UUID,
    key text,
    solr_format text,
    created_date timestamp
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        id,
        search_index_id,
        key_word AS key,
        solr_format,
        created_date
    FROM synonyms
    WHERE search_index_id = p_search_index_id
      AND id = p_synonym_id
      AND is_latest = TRUE;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '8. GetSynonymByKeyWord'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_synonym_by_key_word(
    p_search_index_id UUID,
    p_key_word TEXT
) RETURNS TABLE (
    id UUID,
    search_index_id UUID,
    key text,
    solr_format text,
    created_date timestamp
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        id,
        search_index_id,
        key_word AS key,
        solr_format,
        created_date
    FROM synonyms
    WHERE search_index_id = p_search_index_id
      AND key_word = p_key_word
      AND is_latest = TRUE;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '9. SupersedeLatestFeed'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION supersede_latest_feed(
    p_search_index_id UUID
) RETURNS int AS $$
DECLARE
    rows_updated int;
BEGIN
    UPDATE feeds
    SET is_latest = FALSE,
        superseded_date = CURRENT_TIMESTAMP
    WHERE search_index_id = p_search_index_id
      AND is_latest = TRUE;
    GET DIAGNOSTICS rows_updated = ROW_COUNT;
    RETURN rows_updated;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '10. SupersedeSynonym'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION supersede_synonym(
    p_search_index_id UUID,
    p_synonym_id UUID
) RETURNS int AS $$
DECLARE
    rows_updated int;
BEGIN
    UPDATE synonyms
    SET is_latest = FALSE,
        superseded_date = CURRENT_TIMESTAMP
    WHERE search_index_id = p_search_index_id
      AND id = p_synonym_id
      AND is_latest = TRUE;
    GET DIAGNOSTICS rows_updated = ROW_COUNT;
    RETURN rows_updated;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '11. UpdateSynonym'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION update_synonym(
    p_search_index_id UUID,
    p_synonym_id UUID,
    p_key_word TEXT,
    p_solr_format TEXT
) RETURNS int AS $$
DECLARE
    rows_updated int;
BEGIN
    UPDATE synonyms
    SET key_word = p_key_word,
        solr_format = p_solr_format
    WHERE search_index_id = p_search_index_id
      AND id = p_synonym_id
      AND is_latest = TRUE;
    GET DIAGNOSTICS rows_updated = ROW_COUNT;
    RETURN rows_updated;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '12. delete_feed_credentials'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION delete_feed_credentials(
    p_search_index_id UUID,
    p_username TEXT
) RETURNS int AS $$
DECLARE
    rows_deleted int := 0;
BEGIN
    DELETE FROM feed_credentials
    WHERE search_index_id = p_search_index_id
      AND username = p_username;
    GET DIAGNOSTICS rows_deleted = ROW_COUNT;
    RETURN rows_deleted;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '13. add_search_index'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION add_search_index(
    p_search_index_id UUID,
    p_customer_id UUID,
    p_index_name TEXT,
    p_friendly_name TEXT,
    p_search_instance_id UUID DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO search_index (
        id,
        search_instance_id,
        customer_id,
        index_name,
        friendly_name,
        created_date
    )
    VALUES (
        p_search_index_id,
        p_search_instance_id,
        p_customer_id,
        p_index_name,
        p_friendly_name,
        CURRENT_TIMESTAMP AT TIME ZONE 'UTC'
    );
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '14. dd_synonym'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION add_synonym(
    p_synonym_id UUID,
    p_search_index_id UUID,
    p_key_word TEXT,
    p_solr_format TEXT
)
RETURNS UUID AS $$
BEGIN
    INSERT INTO synonyms (
        id,
        search_index_id,
        key_word,
        solr_format
    )
    VALUES (
        p_synonym_id,
        p_search_index_id,
        p_key_word,
        p_solr_format
    );

    RETURN p_synonym_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '15. get_search_insights_by_data_categories'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_insights_by_data_categories(
    p_search_index_id UUID,
    p_date_from TIMESTAMP,
    p_date_to TIMESTAMP,
    p_data_categories TEXT
)
RETURNS TABLE (
    data_category TEXT,
    data_point TEXT,
    date DATE,
    count INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        d.data_category,
        d.data_point,
        d.date,
        d.count
    FROM search_insights_data d
    JOIN unnest(string_to_array(p_data_categories, ',')) AS category(value)
        ON category.value = d.data_category
    WHERE d.search_index_id = p_search_index_id
      AND d.date >= p_date_from
      AND d.date <= p_date_to;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '16. get_search_insights_search_count_by_date_range'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_insights_search_count_by_date_range(
    p_search_index_id UUID,
    p_date_from TIMESTAMP,
    p_date_to TIMESTAMP
)
RETURNS TABLE (
    date DATE,
    count INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        d.date,
        d.count
    FROM search_index_request_log d
    WHERE d.search_index_id = p_search_index_id
      AND d.date BETWEEN p_date_from AND p_date_to;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '17. get_synonyms'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_synonyms(
    p_search_index_id UUID
)
RETURNS TABLE (
    id UUID,
    search_index_id UUID,
    key TEXT,
    solr_format TEXT,
    created_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        s.id,
        s.search_index_id,
        s.key_word AS key,
        s.solr_format,
        s.created_date
    FROM synonyms s
    WHERE s.search_index_id = p_search_index_id
      AND s.is_latest = TRUE;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '18. get_theme_by_customer_id'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_theme_by_customer_id(
    p_customer_id UUID
)
RETURNS TABLE (
    id UUID,
    primary_hex_colour TEXT,
    secondary_hex_colour TEXT,
    nav_bar_hex_colour TEXT,
    logo_url TEXT,
    missing_image_url TEXT,
    customer_id UUID,
    search_index_id UUID,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.id,
        t.primary_hex_colour,
        t.secondary_hex_colour,
        t.nav_bar_hex_colour,
        t.logo_url,
        t.missing_image_url,
        t.customer_id,
        t.search_index_id,
        t.created_date,
        t.modified_date
    FROM themes t
    WHERE t.customer_id = p_customer_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '19. get_theme_by_id'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_theme_by_id(
    p_theme_id UUID
)
RETURNS TABLE (
    id UUID,
    primary_hex_colour TEXT,
    secondary_hex_colour TEXT,
    nav_bar_hex_colour TEXT,
    logo_url TEXT,
    missing_image_url TEXT,
    customer_id UUID,
    search_index_id UUID,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.id,
        t.primary_hex_colour,
        t.secondary_hex_colour,
        t.nav_bar_hex_colour,
        t.logo_url,
        t.missing_image_url,
        t.customer_id,
        t.search_index_id,
        t.created_date,
        t.modified_date
    FROM themes t
    WHERE t.id = p_theme_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '20. get_theme_by_search_index_id'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_theme_by_search_index_id(
    p_search_index_id UUID
)
RETURNS TABLE (
    id UUID,
    primary_hex_colour TEXT,
    secondary_hex_colour TEXT,
    nav_bar_hex_colour TEXT,
    logo_url TEXT,
    missing_image_url TEXT,
    customer_id UUID,
    search_index_id UUID,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.id,
        t.primary_hex_colour,
        t.secondary_hex_colour,
        t.nav_bar_hex_colour,
        t.logo_url,
        t.missing_image_url,
        t.customer_id,
        t.search_index_id,
        t.created_date,
        t.modified_date
    FROM themes t
    WHERE t.search_index_id = p_search_index_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '21. update_theme'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION update_theme(
    p_theme_id UUID,
    p_primary_hex_colour TEXT,
    p_secondary_hex_colour TEXT,
    p_nav_bar_hex_colour TEXT,
    p_logo_url TEXT,
    p_missing_image_url TEXT
)
RETURNS VOID AS $$
BEGIN
    UPDATE themes
    SET
        primary_hex_colour = p_primary_hex_colour,
        secondary_hex_colour = p_secondary_hex_colour,
        nav_bar_hex_colour = p_nav_bar_hex_colour,
        logo_url = p_logo_url,
        missing_image_url = p_missing_image_url,
        modified_date = CURRENT_TIMESTAMP AT TIME ZONE 'UTC'
    WHERE id = p_theme_id;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '22. get_theme_by_customer_endpoint'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_theme_by_customer_endpoint(
    p_customer_endpoint TEXT
)
RETURNS TABLE (
    id UUID,
    primary_hex_colour TEXT,
    secondary_hex_colour TEXT,
    nav_bar_hex_colour TEXT,
    logo_url TEXT,
    missing_image_url TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.id,
        t.primary_hex_colour,
        t.secondary_hex_colour,
        t.nav_bar_hex_colour,
        t.logo_url,
        t.missing_image_url
    FROM themes t
    INNER JOIN customers c ON t.customer_id = c.id
    WHERE c.customer_endpoint = p_customer_endpoint;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '23. get_search_index_query_credentials_by_customer_endpoint'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_index_query_credentials_by_customer_endpoint(
    p_customer_endpoint TEXT
)
RETURNS TABLE (
    id UUID,
    search_index_name TEXT,
    search_instance_name TEXT,
    search_instance_endpoint TEXT,
    api_key TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        si.id,
        LOWER(si.index_name) AS search_index_name,
        i.service_name AS search_instance_name,
        i.root_endpoint AS search_instance_endpoint,
        ik.api_key
    FROM search_index si
    INNER JOIN search_instances i ON i.id = si.search_instance_id
    INNER JOIN customers c ON si.customer_id = c.id
    INNER JOIN search_instance_keys ik ON ik.search_instance_id = i.id
        AND ik.key_type = 'Query'
        AND ik.name = 'Query key'
        AND ik.is_latest = TRUE
    WHERE c.customer_endpoint = p_customer_endpoint;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '24. get_feed_credentials_username'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_feed_credentials_username(
    p_search_index_id UUID
)
RETURNS TABLE (
    search_index_id UUID,
    username TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        fc.search_index_id,
        fc.username,
        fc.created_date,
        fc.modified_date
    FROM feed_credentials fc
    WHERE fc.search_index_id = p_search_index_id
    ORDER BY fc.created_date
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;


-- =============================
DO $$ BEGIN RAISE NOTICE '25. get_feed_data_format'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_feed_data_format(
    p_customer_id UUID,
    p_search_index_name TEXT
)
RETURNS TEXT AS $$
DECLARE
    data_format TEXT;
BEGIN
    SELECT f.data_format
    INTO data_format
    FROM search_index si
    INNER JOIN feeds f ON f.search_index_id = si.id AND f.is_latest = true
    WHERE si.customer_id = p_customer_id
      AND si.index_name = p_search_index_name
    LIMIT 1;

    RETURN data_format;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '26. get_latest_generic_synonyms_by_category'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_latest_generic_synonyms_by_category(
    p_category TEXT
)
RETURNS TABLE (
    id UUID,
    category TEXT,
    solr_format TEXT,
    created_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        id,
        category,
        solr_format,
        created_date
    FROM synonyms
    WHERE category = p_category
      AND is_latest = true;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '27. get_search_index_credentials'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_index_credentials(
    p_customer_id UUID,
    p_search_index_name TEXT
)
RETURNS TABLE (
    search_index_id UUID,
    search_index_name_lower TEXT,
    search_instance_id UUID,
    search_instance_name TEXT,
    root_endpoint TEXT,
    api_key TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        si.id,
        LOWER(si.index_name), -- FIXED: Column name to snake_case
        i.id,
        i.service_name,
        i.root_endpoint,
        ik.api_key
    FROM search_index si
    -- FIXED: Join search_index to search_instances using the FK search_instance_id
    INNER JOIN search_instances i ON i.id = si.search_instance_id
    -- FIXED: Join search_instances to search_instance_keys using the FK search_instance_id
    INNER JOIN search_instance_keys ik ON ik.search_instance_id = i.id
        AND ik.key_type = 'Admin'
        AND ik.name = 'Primary Admin key'
        AND ik.is_latest = true
    WHERE si.customer_id = p_customer_id
      AND si.index_name = p_search_index_name; -- FIXED: Column name to snake_case
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '28. get_search_index_feed_processing_data'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_search_index_feed_processing_data(
    p_customer_id UUID,
    p_search_index_name TEXT
)
RETURNS TABLE (
    search_index_id UUID,
    search_index_name_lower TEXT,
    search_instance_id UUID,
    search_instance_name TEXT,
    root_endpoint TEXT,
    api_key TEXT,
    feed_data_format TEXT,
    customer_endpoint TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        si.id,
        LOWER(si.index_name), -- FIXED: Column name to snake_case
        i.id,
        i.service_name,
        i.root_endpoint,
        ik.api_key,
        f.data_format,
        c.customer_endpoint
    FROM search_index si
    -- FIXED: Join search_index to search_instances using the FK search_instance_id
    INNER JOIN search_instances i ON i.id = si.search_instance_id
    -- FIXED: Join search_instances to search_instance_keys using the FK search_instance_id
    INNER JOIN search_instance_keys ik ON ik.search_instance_id = i.id
        AND ik.key_type = 'Admin'
        AND ik.name = 'Primary Admin key'
        AND ik.is_latest = true
    LEFT JOIN feeds f ON f.search_index_id = si.id
    LEFT JOIN customers c ON si.customer_id = c.id
    WHERE si.customer_id = p_customer_id
      AND si.index_name = p_search_index_name -- FIXED: Column name to snake_case
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '29. merge_feed_documents'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION merge_feed_documents(
    p_search_index_id UUID,
    p_new_feed_documents UUID[]
)
RETURNS VOID AS $$
DECLARE
    utc_now TIMESTAMP := NOW();
BEGIN
    -- Update existing documents
    UPDATE feed_current_documents AS target
    SET created_date = utc_now
    WHERE target.search_index_id = search_index_id
      AND target.id = ANY(new_feed_documents);

    -- Insert new documents
    INSERT INTO feed_current_documents (id, search_index_id, created_date)
    SELECT doc_id, search_index_id, utc_now
    FROM UNNEST(new_feed_documents) AS doc_id
    WHERE doc_id NOT IN (
        SELECT id
        FROM feed_current_documents
        WHERE search_index_id = p_search_index_id
    );

    -- Delete documents not in the new list
    DELETE FROM feed_current_documents
    WHERE search_index_id = p_search_index_id
      AND id NOT IN (SELECT * FROM UNNEST(new_feed_documents));
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '30. add_data_points'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION add_data_points(
    search_index_id UUID,
    search_insights_data search_insights_data_type[]
)
RETURNS VOID AS $$
DECLARE
    -- Removed 'utc_now TIMESTAMP := NOW();' to use NOW() directly where possible, 
    -- and removed 'record_item search_insights_data_type;' to declare it in the loop.
BEGIN
    -- Declaring the loop variable here simplifies the DECLARE block above.
    FOR record_item IN SELECT * FROM UNNEST(search_insights_data)
    LOOP
        INSERT INTO search_insights_data (
            search_index_id,
            data_category,
            data_point,
            count,
            date,
            modified_date
        )
        VALUES (
            search_index_id,
            record_item.data_category,
            record_item.data_point,
            1,
            record_item.date,
            NOW() -- Using NOW() directly
        )
        ON CONFLICT (search_index_id, data_category, data_point, date)
        DO UPDATE SET
            count = search_insights_data.count + 1,
            modified_date = NOW(); -- Using NOW() directly
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '31. add_search_request'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION add_search_request(
    p_search_index_id UUID,
    p_date DATE -- We use DATE since the index is grouped by day
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO search_index_request_log (
        search_index_id,
        date,
        count,
        created_date,
        modified_date
    )
    VALUES (
        p_search_index_id,
        p_date,
        1, -- Initial count of 1
        NOW(),
        NOW()
    )
    ON CONFLICT (search_index_id, date) -- Conflict based on the UNIQUE INDEX
    DO UPDATE SET
        count = search_index_request_log.count + 1,
        modified_date = NOW();
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '32. add_feed_credentials'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION add_feed_credentials(
    p_search_index_id UUID,
    p_username TEXT,
    p_password_hash TEXT
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO feed_credentials (
        id,
        search_index_id,
        username,
        password_hash,
        created_date
    )
    VALUES (
        gen_random_UUID(),
        p_search_index_id,
        p_username,
        p_password_hash,
        NOW()
    );
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '33. delete_feed_credentials'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION delete_feed_credentials(
    p_search_index_id UUID,
    p_username TEXT
)
RETURNS VOID AS $$
BEGIN
    DELETE FROM feed_credentials
    WHERE search_index_id = p_search_index_id
      AND username = p_username;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '34. get_feed_credentials'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION get_feed_credentials(
    p_search_index_id UUID,
    p_username TEXT
) RETURNS TABLE (
    search_index_id UUID,
    username TEXT,
    created_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        search_index_id,
        username,
        created_date
    FROM feed_credentials
    WHERE search_index_id = p_search_index_id
      AND username = p_username;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '35. update_feed_credentials'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION update_feed_credentials(
    p_search_index_id UUID,
    p_username TEXT,
    p_password_hash TEXT
) RETURNS int AS $$
DECLARE
    rows_updated int := 0;
BEGIN
    UPDATE feed_credentials
    SET password_hash = p_password_hash,
        modified_date = CURRENT_TIMESTAMP
    WHERE search_index_id = p_search_index_id
      AND username = p_username;
    GET DIAGNOSTICS rows_updated = ROW_COUNT;
    RETURN rows_updated;
END;
$$ LANGUAGE plpgsql;

-- =============================
DO $$ BEGIN RAISE NOTICE '36. add_feed'; END $$;
-- =============================
CREATE OR REPLACE FUNCTION add_feed(
    p_search_index_id UUID,
    p_feed_type TEXT,
    p_feed_cron TEXT
) RETURNS int AS $$
DECLARE
    rows_inserted int := 0;
BEGIN
    -- Supersede previous latest feed
    PERFORM supersede_latest_feed(p_search_index_id);

    -- Insert new feed
    INSERT INTO feeds (
        search_index_id,
        feed_type,
        feed_schedule_cron,
        created_date,
        is_latest
    )
    VALUES (
        p_search_index_id,
        p_feed_type,
        p_feed_cron,
        CURRENT_TIMESTAMP,
        TRUE
    );
    GET DIAGNOSTICS rows_inserted = ROW_COUNT;
    RETURN rows_inserted;
END;
$$ LANGUAGE plpgsql;